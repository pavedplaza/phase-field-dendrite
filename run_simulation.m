function results = run_simulation(params)
% RUN_SIMULATION Run phase-field dendrite growth simulation
% 运行相场枝晶生长模拟
%
% Syntax:
%   results = run_simulation(params)
%
% Input:
%   params - Structure containing simulation parameters
%           Must be generated by config_default()
%
% Output:
%   results - Structure containing:
%            .phi_history, .U_history, .time_history
%            .tip_position_history_6, .tip_distance_history_6
%            .tip_velocity_history_6, .tip_curvature_history_6
%            .interface_history, .final_phi, .final_U
%            .params, .total_steps, .final_time
%
% Example:
%   params = config_default();
%   params.visualization = true;
%   results = run_simulation(params);
%
% See also: config_default, phase_field_simulation

    %% ==================== Section 1: Parameter Validation ====================
    % 验证输入参数
    if nargin < 1
        error('run_simulation需要params结构体作为输入。使用: params = config_default();');
    end

    % Extract parameters (保持与legacy相同的变量名)
    % Extract parameters (keep same variable names as legacy)
    Nx = params.Nx;
    Ny = params.Ny;
    dx = params.dx;
    dy = params.dy;

    % Material parameters | 材料参数
    k_partition = params.k_partition;
    epsilon_aniso = params.epsilon_aniso;
    m_aniso = params.m_aniso;
    omega0_aniso = params.omega0_aniso;
    lambda_coup = params.lambda_coup;
    D_coefficient = params.D_coefficient;
    theta_field = params.theta_field;

    % Control parameters | 控制参数
    total_time = params.total_time;
    print_interval = params.output_interval;

    % Convert boolean to integer
    % 将布尔值转换为整数
    if isfield(params, 'visualization')
        visualization_mode = params.visualization;
    else
        visualization_mode = false;
    end

    if isfield(params, 'tip_tracking')
        enable_tip_tracking = params.tip_tracking;
    else
        enable_tip_tracking = true;
    end

    % Boundary conditions | 边界条件
    if isfield(params, 'boundary_condition')
        boundary_condition_type = params.boundary_condition;
    else
        boundary_condition_type = 'periodic';
    end

    % Calculate time step (CFL condition)
    % 计算时间步长(CFL条件)
    dtime = dx^2 / (4 * D_coefficient);
    if isfield(params, 'safety_factor')
        dtime = params.safety_factor * dtime;
    else
        dtime = 0.25 * dtime;  % Default safety factor | 默认安全系数
    end

    % Calculate derived parameters | 计算派生参数
    NxNy = Nx * Ny;
    a1 = 0.8839;
    W_over_d0 = lambda_coup / a1;

    % Get resampling option from params | 从参数获取重采样选项
    if isfield(params, 'enable_resampling')
        enable_resampling = params.enable_resampling;
    else
        enable_resampling = true;  % Default: enable resampling | 默认：开启重采样
    end

    % Velocity field parameters | 速度场参数
    if isfield(params, 'velocity_field')
        velocity_field_type = params.velocity_field;
    else
        velocity_field_type = 'none';  % Default: no velocity field | 默认：无速度场
    end

    % Extract velocity field parameters | 提取速度场参数
    if isfield(params, 'v_x_magnitude')
        v_x_magnitude = params.v_x_magnitude;
    else
        v_x_magnitude = 0.0;
    end

    if isfield(params, 'v_y_magnitude')
        v_y_magnitude = params.v_y_magnitude;
    else
        v_y_magnitude = 0.0;
    end

    if isfield(params, 'shear_rate')
        shear_rate = params.shear_rate;
    else
        shear_rate = 0.0;
    end

    if isfield(params, 'vortex_strength')
        vortex_strength = params.vortex_strength;
    else
        vortex_strength = 0.0;
    end

    %% ==================== Section 2: Add PFM_core to Path ====================
    % 添加PFM_core到路径(带错误检查)
    if exist('PFM_core', 'dir')
        addpath('PFM_core');
        fprintf('PFM_core已添加到路径\n');
    else
        error('找不到PFM_core目录。当前目录: %s', pwd);
    end

    %% ==================== Section 3: Print Simulation Info ====================
    % 打印仿真信息
    time0 = clock();
    format long;

    fprintf('=== 基于文献的严格相场-浓度场耦合模拟 ===\n');
    fprintf('网格参数: %dx%d, 区域: %.2fx%.2f\n', Nx, Ny, Nx*dx, Ny*dy);
    fprintf('  - 溶质分配系数 k: %.3f\n', k_partition);
    fprintf('  - 各向异性强度 ε: %.3f\n', epsilon_aniso);
    fprintf('  - 各向异性模数 m: %d (六重对称)\n', m_aniso);
    fprintf('  - 优先生长方向 ψ₀: %.1f° (沿x轴)\n', omega0_aniso);
    fprintf('  - 耦合强度 λ: %.1f\n', lambda_coup);
    fprintf('  - 扩散系数 D: %.3f\n', D_coefficient);
    fprintf('  - 无量纲过冷度 θ: %.1f\n', theta_field);

    fprintf('时间步长: %.6e\n', dtime);
    fprintf('估计总步数: %d\n', ceil(total_time / dtime) + 100);

    %% ==================== Section 4: Initialize Fields ====================
    % 初始化场变量
    fprintf('\n初始化相场和浓度场...\n');

    phi = -ones(Ny, Nx);       % Initialize to all liquid phase | 初始化为全液相
    U = zeros(Ny, Ny);         % Initial uniform concentration field | 初始均匀浓度场

    % Create initial seed | 创建初始晶核
    seed_radius = 3.2;
    cx = round(Nx / 2);
    cy = round(Ny / 2);

    % Create circular seed at center | 在中心创建圆形晶核
    for i = 1:Nx
        for j = 1:Ny
            if ((i - cx)^2 + (j - cy)^2) < seed_radius^2
                phi(i, j) = 1.0;  % Set seed interior to solid phase | 晶核内部设为固相
            end
        end
    end

    % Define six-direction visualization reference lines | 定义六方向可视化参考线
    fprintf('定义六方向生长参考线...\n');

    % Define six preferred growth direction angles (radians): 30°, 90°, 150°, 210°, 270°, 330°
    % 定义六个优先生长方向角度(弧度)：30°, 90°, 150°, 210°, 270°, 330°
    six_tip_angles = [pi/6, pi/2, 5*pi/6, 7*pi/6, 9*pi/6, 11*pi/6];
    six_tip_directions = [cos(six_tip_angles); sin(six_tip_angles)]';  % 6×2 direction matrix | 6×2方向矩阵

    center_x = cx * dx;  % Convert to physical coordinates | 转换为物理坐标
    center_y = cy * dy;

    % Create six-direction reference line data for visualization | 创建六方向参考线数据用于可视化
    six_reference_lines = cell(6, 1);
    for tip_id = 1:6
        angle = six_tip_angles(tip_id);

        % Reference line extending from center outward, length is half of computational domain
        % 从中心向外延伸的参考线，长度为计算域的一半
        line_length = min(Nx, Ny) * dx / 2.5;

        % Generate reference line coordinate points | 生成参考线坐标点
        num_points = 100;
        r_values = linspace(0, line_length, num_points);
        line_x = center_x + r_values .* cos(angle);
        line_y = center_y + r_values .* sin(angle);

        % Store reference line coordinates | 存储参考线坐标
        six_reference_lines{tip_id} = [line_x', line_y'];
    end

    phi_init = phi;
    U_init = U;

    fprintf('初始条件:\n');
    fprintf('  - 固相像素数: %d / %d (%.1f%%)\n', ...
            sum(phi(:) > 0), Nx*Ny, 100*sum(phi(:) > 0)/(Nx*Ny));
    fprintf('  - 六方向参考线：角度 [0°, 60°, 120°, 180°, 240°, 300°]\n');

    %% ==================== Section 5: Initialize Data Storage ====================
    % 初始化数据存储
    max_saves = ceil(total_time / print_interval) + 10;

    phi_history = cell(max_saves, 1);
    U_history = cell(max_saves, 1);
    time_history = zeros(max_saves, 1);

    % Velocity field history initialization | 速度场历史初始化
    Vx_history = cell(max_saves, 1);   % Store velocity field X component | 存储速度场X分量
    Vy_history = cell(max_saves, 1);   % Store velocity field Y component | 存储速度场Y分量

    % Interface tracking variables initialization | 界面追踪变量初始化
    interface_history = zeros(max_saves, 1);      % Store interface length evolution | 存储界面长度演化
    contour_history = cell(max_saves, 1);         % Store interface coordinate data | 存储界面坐标数据

    % Six-fold symmetric dendrite tip dynamics parameters storage initialization
    % 六重对称枝晶尖端动力学参数存储初始化
    tip_position_history_6 = zeros(max_saves, 6, 2);  % [time, tip ID, coordinates(x,y)] | [时间, 尖端ID, 坐标(x,y)]
    tip_distance_history_6 = zeros(max_saves, 6);      % [time, tip ID] distance | [时间, 尖端ID] 距离
    tip_velocity_history_6 = zeros(max_saves, 6);      % [time, tip ID] velocity | [时间, 尖端ID] 速度
    tip_curvature_history_6 = zeros(max_saves, 6);     % [time, tip ID] curvature radius | [时间, 尖端ID] 曲率半径
    tip_history_buffer_6 = [];                        % Six-tip history buffer structure array | 六尖端历史缓冲区结构体数组

    % Store initial state | 存储初始状态
    phi_history{1} = phi;
    U_history{1} = U;
    time_history(1) = 0;

    %% ==================== Section 6: Initial Interface Detection ====================
    % 初始界面检测
    fprintf('检测初始固液界面...\n');

    contour_level = 0;

    % Create coordinate grid | 创建坐标网格
    x_coords = ((0:Nx-1) + 0.5) * dx;  % Use grid center coordinates | 使用网格中心坐标
    y_coords = ((0:Ny-1) + 0.5) * dy;

    % Extract specified contour line, use safer method | 提取指定等值线，使用更安全的方法
    [C, h] = contour(x_coords, y_coords, phi, [contour_level contour_level]);

    % If contour data exists | 如果有等值线数据
    if ~isempty(C)
        % Extract coordinates from contour matrix C | 从轮廓矩阵C中提取坐标
        contour_data = [];
        i = 1;
        while i < size(C, 2)
            level = C(1, i);
            num_points = C(2, i);

            if num_points > 0
                x_coords_contour = C(1, i+1:i+num_points);
                y_coords_contour = C(2, i+1:i+num_points);

                if isempty(contour_data)
                    contour_data = [x_coords_contour(:), y_coords_contour(:)];
                else
                    contour_data = [contour_data; x_coords_contour(:), y_coords_contour(:)];
                end
            end

            i = i + num_points + 1;
        end

        % Filter valid contour points (avoid boundary anomalies) | 筛选有效的等值线点 (避免边界异常)
        valid_points = true(size(contour_data, 1), 1);

        for i = 2:size(contour_data, 1)-1
            % Calculate distance between adjacent points | 计算相邻点的距离
            dist_x = contour_data(i, 1) - contour_data(i-1, 1);
            dist_y = contour_data(i, 2) - contour_data(i-1, 2);
            dist = sqrt(dist_x^2 + dist_y^2);

            % If distance exceeds reasonable range, mark as invalid | 如果距离超过合理范围，标记为无效
            max_reasonable_dist = 3 * max(dx, dy);  % Maximum reasonable distance | 最大合理距离
            if dist > max_reasonable_dist
                % Check if near boundary (filter boundary anomaly points) | 检查是否接近边界 (过滤边界异常点)
                if contour_data(i, 1) < 2*dx || contour_data(i, 1) > (Nx-2)*dx || ...
                   contour_data(i, 2) < 2*dy || contour_data(i, 2) > (Ny-2)*dy
                    valid_points(i) = false;
                end
            end
        end

        % Extract valid points | 提取有效点
        if sum(valid_points) > 2  % Keep at least 3 points | 至少保留3个点
            contour_data = contour_data(valid_points, :);
        end
    else
        contour_data = [];
    end

    contour_lines = C;  % Return contour matrix | 返回轮廓矩阵
    interface_length = size(contour_data, 1);
    interface_history(1) = interface_length;
    contour_history{1} = contour_data;
    fprintf('初始界面长度: %.2f 网格单位\n', interface_length);

    %% ==================== Section 7: Initialize Visualization ====================
    % 初始化可视化
    if visualization_mode
        initialize_corrected_visualization(Nx, Ny);
        fprintf('可视化已启用 (Figure 2)\n');
    end

    % Initialize interface tracking visualization (separate window) | 初始化界面追踪可视化 (独立窗口)
    if visualization_mode
        initialize_interface_visualization(Nx, Ny, dx, dy);
        fprintf('界面追踪可视化已启用 (Figure 3)\n');
    end

    % Initialize velocity field visualization if velocity field is enabled | 如果启用速度场，初始化速度场可视化
    if visualization_mode && ~strcmp(velocity_field_type, 'none')
        initialize_velocity_visualization(Nx, Ny, dx, dy);
        fprintf('速度场可视化已启用 (Figure 4)\n');
    end

    %% ==================== Section 8: Main Time Loop ====================
    % 主时间循环
    fprintf('\n=== 基于时间的严格耦合模拟 ===\n');
    fprintf('目标模拟时间: %.1f τ₀\n', total_time);
    fprintf('时间步长: %.6e τ₀\n', dtime);
    fprintf('估计总步数: %d\n', ceil(total_time / dtime) + 100);
    fprintf('输出间隔: %.1f τ₀\n', print_interval);

    % Initialize time and loop variables | 初始化时间和循环变量
    current_time = 0;
    istep = 0;
    next_print_time = print_interval;
    save_count = 1;  % Initial state already saved at position 1 | 初始状态已保存在第1个位置

    max_steps = 50000;  % Prevent infinite loop safety upper limit | 防止无限循环的安全上限

    % Initialize velocity field video writer (if enabled)
    % 初始化速度场视频写入对象（如果启用）
    velocity_video_writer = [];
    if visualization_mode && ~strcmp(velocity_field_type, 'none') && isfield(params, 'save_video') && params.save_video
        % Determine video filename prefix | 确定视频文件名前缀
        if ~strcmp(velocity_field_type, 'none')
            video_prefix = 'velocity_field_';
        else
            video_prefix = 'basic_growth_';
        end

        % Create video writer for velocity field visualization
        % 创建速度场可视化的视频写入对象
        velocity_video_writer = VideoWriter(sprintf('%scontour.mp4', video_prefix), 'MPEG-4');
        fps = 10;
        if isfield(params, 'video_fps')
            fps = params.video_fps;
        end
        velocity_video_writer.FrameRate = fps;
        open(velocity_video_writer);
        fprintf('速度场视频录制已启动: %scontour.mp4\n', video_prefix);
    end

    while current_time < total_time && istep < max_steps
        istep = istep + 1;

        % Pre-allocate arrays for this time step | 为此时间步预分配数组
        lap_phi = zeros(Ny, Nx);
        lap_U = zeros(Ny, Nx);
        phidx = zeros(Ny, Nx);
        phidy = zeros(Ny, Nx);
        Udx = zeros(Ny, Nx);
        Udy = zeros(Ny, Nx);
        epsilon_arr = zeros(Ny, Nx);
        epsilon_deriv_arr = zeros(Ny, Nx);
        interface_mask = false(Ny, Nx);  % Interface marker | 界面标记

        % === First pass: Calculate gradients and Laplacians, detect interface region ===
        % 第一步：计算梯度和拉普拉斯算子，并检测界面区域
        for i = 1:Nx
            for j = 1:Ny
                % Apply periodic boundary conditions | 应用周期性边界条件
                [ip, im, jp, jm] = apply_boundary_conditions(i, j, Nx, Ny, boundary_condition_type);

                % Calculate phase field Laplacian | 计算相场拉普拉斯算子
                lap_phi(i,j) = (phi(ip,j) + phi(im,j) + phi(i,jp) + phi(i,jm) - 4*phi(i,j)) / (dx*dx);

                % Calculate phase field gradient | 计算相场梯度
                phidx_temp = (phi(ip,j) - phi(im,j)) / (2*dx);
                phidy_temp = (phi(i,jp) - phi(i,jm)) / (2*dy);
                phidx(i,j) = phidx_temp;
                phidy(i,j) = phidy_temp;

                % Detect interface: |∇φ| > eps_numerical | 检测界面：|∇φ| > eps_numerical
                grad_phi_mag = sqrt(phidx_temp^2 + phidy_temp^2);
                if grad_phi_mag > 1e-12  % eps_numerical | 数值精度常量
                    interface_mask(i,j) = true;
                end
            end
        end

        % Calculate interface statistics | 统计界面区域信息
        interface_points = sum(interface_mask(:));
        interface_percentage = 100.0 * interface_points / (Nx * Ny);

        % If no interface region, skip this calculation | 如果没有界面区域，跳过本次计算
        if ~any(interface_mask(:))
            fprintf('时间: %8.4f/%.1f τ₀, 步数: %4d, 无界面变化，跳过计算\n', current_time, total_time, istep);
            continue;
        end

        % === Second loop: Calculate remaining spatial derivatives (only in interface region) ===
        % 第二个循环：计算剩余空间导数（只在界面区域）
        for i = 1:Nx
            for j = 1:Ny
                % Only calculate derivatives for interface region | 只计算界面区域的导数
                if ~interface_mask(i,j)
                    continue;
                end

                % Apply periodic boundary conditions | 应用周期性边界条件
                [ip, im, jp, jm] = apply_boundary_conditions(i, j, Nx, Ny, boundary_condition_type);

                % Calculate U field Laplacian (phase field already calculated above)
                % 计算U场拉普拉斯算子（相场的已在前面计算）
                lap_U(i,j) = (U(ip,j) + U(im,j) + U(i,jp) + U(i,jm) - 4*U(i,j)) / (dx*dx);

                % Calculate U field gradient | 计算U场梯度
                Udx(i,j) = (U(ip,j) - U(im,j)) / (2*dx);
                Udy(i,j) = (U(i,jp) - U(i,jm)) / (2*dy);

                % Calculate anisotropy parameters (based on already calculated phase field gradient)
                % 计算各向异性参数（基于已计算的相场梯度）
                theta = atan2(phidy(i,j), phidx(i,j));
                epsilon_arr(i,j) = 1.0 + epsilon_aniso * cos(m_aniso * (theta - omega0_aniso));
                epsilon_deriv_arr(i,j) = -epsilon_aniso * m_aniso * sin(m_aniso * (theta - omega0_aniso));
            end
        end

        % Save current phi for calculating time derivative | 保存当前phi用于计算时间导数
        phi_old = phi;

        % === Third loop: Update field variables (only in interface region) ===
        % 第三个循环：更新场变量（只在界面区域）
        for i = 1:Nx
            for j = 1:Ny
                % Only update field variables in interface region | 只更新界面区域的场变量
                if ~interface_mask(i,j)
                    continue;
                end

                % Apply periodic boundary conditions | 应用周期性边界条件
                [ip, im, jp, jm] = apply_boundary_conditions(i, j, Nx, Ny, boundary_condition_type);

                phi_old_val = phi_old(i,j);
                U_old_val = U(i,j);
                epsilon_val = epsilon_arr(i,j);
                epsilon_deriv_val = epsilon_deriv_arr(i,j);

                % === Phase field equation calculation | === 相场方程计算
                % Check phase field gradient magnitude | 检查相场梯度幅值
                grad_phi_mag = sqrt(phidx(i,j)^2 + phidy(i,j)^2);

                if grad_phi_mag < 1e-12
                    % If phase field gradient too small, set anisotropy and diffusion terms to 0
                    % 如果相场梯度太小，各向异性项和扩散项都设为0
                    anisotropy_terms = 0;
                    diffusion_term = 0;
                else
                    % Normal calculation of anisotropy and diffusion terms | 正常计算各向异性项和扩散项

                    % Correctly implement anisotropy term: -∂/∂x[A(ψ)A'(ψ)∂ϕ/∂y] + ∂/∂y[A(ψ)A'(ψ)∂ϕ/∂x]
                    % 正确实现各向异性项: -∂/∂x[A(ψ)A'(ψ)∂ϕ/∂y] + ∂/∂y[A(ψ)A'(ψ)∂ϕ/∂x]

                    % Calculate ∂/∂x[A(ψ)A'(ψ)∂ϕ/∂y] | 计算 ∂/∂x[A(ψ)A'(ψ)∂ϕ/∂y]
                    term_A_east = epsilon_arr(ip,j) * epsilon_deriv_arr(ip,j) * phidy(ip,j);
                    term_A_west = epsilon_arr(im,j) * epsilon_deriv_arr(im,j) * phidy(im,j);
                    dAdphidy_dx = (term_A_east - term_A_west) / (2*dx);

                    % Calculate ∂/∂y[A(ψ)A'(ψ)∂ϕ/∂x] | 计算 ∂/∂y[A(ψ)A'(ψ)∂ϕ/∂x]
                    term_B_north = epsilon_arr(i,jp) * epsilon_deriv_arr(i,jp) * phidx(i,jp);
                    term_B_south = epsilon_arr(i,jm) * epsilon_deriv_arr(i,jm) * phidx(i,jm);
                    dAdphidx_dy = (term_B_north - term_B_south) / (2*dy);

                    anisotropy_terms = -dAdphidy_dx + dAdphidx_dy;

                    % Correctly calculate diffusion term: ∇·(A(ψ)²∇ϕ)
                    % 正确计算扩散项: ∇·(A(ψ)²∇ϕ)
                    % Use flux method to calculate divergence, ensuring anisotropy is correctly implemented
                    % 使用通量方法计算散度，确保各向异性正确实现
                    A2_center = epsilon_val^2;

                    % x-direction flux: use average A² value at interface (arithmetic mean)
                    % x方向通量：使用界面处的平均A²值（算术平均）
                    A2_east = 0.5 * (A2_center + epsilon_arr(ip,j)^2);
                    A2_west = 0.5 * (A2_center + epsilon_arr(im,j)^2);

                    flux_x_east = A2_east * (phi(ip,j) - phi_old_val) / dx;
                    flux_x_west = A2_west * (phi_old_val - phi(im,j)) / dx;
                    div_x = (flux_x_east - flux_x_west) / dx;

                    % y-direction flux | y方向通量
                    A2_north = 0.5 * (A2_center + epsilon_arr(i,jp)^2);
                    A2_south = 0.5 * (A2_center + epsilon_arr(i,jm)^2);

                    flux_y_north = A2_north * (phi(i,jp) - phi_old_val) / dy;
                    flux_y_south = A2_south * (phi_old_val - phi(i,jm)) / dy;
                    div_y = (flux_y_north - flux_y_south) / dy;

                    diffusion_term = div_x + div_y;
                end

                % Double-well potential term and driving force term | 双阱势项和驱动力项
                double_well_term = phi_old_val * (1.0 - phi_old_val^2);
                driving_force = -lambda_coup * (1.0 - phi_old_val^2)^2 * (theta_field + k_partition * U_old_val);

                % Phase field right-hand side term | 相场右端项
                phi_rhs = diffusion_term + anisotropy_terms + double_well_term + driving_force;

                % Time scale coefficient - based on theoretical equation A(ψ)²[k(1+(1-k)U)] ∂ϕ/∂t
                % 时间尺度系数 - 根据理论方程 A(ψ)²[k(1+(1-k)U)] ∂ϕ/∂t
                time_coeff_phi = A2_center * (k_partition * (1.0 + (1.0 - k_partition) * U_old_val));

                % Phase field time integration | 相场时间积分
                phi(i,j) = phi_old_val + dtime * phi_rhs / time_coeff_phi;

                % === Concentration field equation calculation | === 浓度场方程计算
                phi_change_rate = (phi(i,j) - phi_old_val) / dtime;

                % Term 1: Diffusion term ∇·[D(1-ϕ)/2 ∇U]
                % 项1: 扩散项 ∇·[D(1-ϕ)/2 ∇U]
                % Use flux method to calculate variable-coefficient diffusion term, referencing phase field calculation method
                % 使用通量方法计算变系数扩散项，参照相场方程计算方法
                D_center = D_coefficient * (1.0 - phi_old_val) / 2.0;

                % x-direction flux: use average diffusion coefficient value at interface
                % x方向通量：使用界面处的平均扩散系数值
                D_east = 0.5 * (D_center + D_coefficient * (1.0 - phi(ip,j)) / 2.0);
                D_west = 0.5 * (D_center + D_coefficient * (1.0 - phi(im,j)) / 2.0);

                flux_x_east = D_east * (U(ip,j) - U_old_val) / dx;
                flux_x_west = D_west * (U_old_val - U(im,j)) / dx;
                div_x_diffusion = (flux_x_east - flux_x_west) / dx;

                % y-direction flux | y方向通量
                D_north = 0.5 * (D_center + D_coefficient * (1.0 - phi(i,jp)) / 2.0);
                D_south = 0.5 * (D_center + D_coefficient * (1.0 - phi(i,jm)) / 2.0);

                flux_y_north = D_north * (U(i,jp) - U_old_val) / dy;
                flux_y_south = D_south * (U_old_val - U(i,jm)) / dy;
                div_y_diffusion = (flux_y_north - flux_y_south) / dy;

                div_diffusion = div_x_diffusion + div_y_diffusion;

                % Term 2: Coupling term divergence ∇·[ (1+(1-k)U)/(2√2) (∂ϕ/∂t)(∇ϕ/|∇ϕ|) ]
                % 项2: 耦合项散度 ∇·[ (1+(1-k)U)/(2√2) (∂ϕ/∂t)(∇ϕ/|∇ϕ|) ]

                % Correct coupling flux divergence calculation: use direction-specific coupling coefficients
                % 修正耦合通量散度计算：使用方向特定的耦合系数
                % Calculate gradient magnitude at each direction | 计算各个方向的梯度幅值
                grad_mag_east = sqrt(phidx(ip,j)^2 + phidy(ip,j)^2);
                grad_mag_west = sqrt(phidx(im,j)^2 + phidy(im,j)^2);
                grad_mag_north = sqrt(phidx(i,jp)^2 + phidy(i,jp)^2);
                grad_mag_south = sqrt(phidx(i,jm)^2 + phidy(i,jm)^2);

                % Check gradient magnitude at all directions, if any is less than eps_numerical, entire coupling term is 0
                % 检查所有方向的梯度幅值，如果任何一个小于eps_numerical，则整个耦合项为0
                if grad_mag_east < 1e-12 || grad_mag_west < 1e-12 || ...
                   grad_mag_north < 1e-12 || grad_mag_south < 1e-12
                    % If any direction gradient too small, set entire coupling term divergence to 0
                    % 如果任何方向梯度太小，整个耦合项散度设为0
                    div_coupling = 0;
                else
                    % All direction gradients large enough, normal calculation of coupling term divergence
                    % 所有方向梯度都足够大，正常计算耦合项散度

                    % x-direction coupling flux - use corresponding node U value to calculate coupling coefficient
                    % x方向耦合通量 - 使用对应节点的U值计算耦合系数
                    coupling_coeff_east = (1.0 + (1.0 - k_partition) * U(ip,j)) / (2.0 * sqrt(2.0));
                    coupling_coeff_west = (1.0 + (1.0 - k_partition) * U(im,j)) / (2.0 * sqrt(2.0));

                    coupling_flux_x_east = coupling_coeff_east * phi_change_rate * phidx(ip,j) / grad_mag_east;
                    coupling_flux_x_west = coupling_coeff_west * phi_change_rate * phidx(im,j) / grad_mag_west;

                    % y-direction coupling flux - use corresponding node U value to calculate coupling coefficient
                    % y方向耦合通量 - 使用对应节点的U值计算耦合系数
                    coupling_coeff_north = (1.0 + (1.0 - k_partition) * U(i,jp)) / (2.0 * sqrt(2.0));
                    coupling_coeff_south = (1.0 + (1.0 - k_partition) * U(i,jm)) / (2.0 * sqrt(2.0));

                    coupling_flux_y_north = coupling_coeff_north * phi_change_rate * phidy(i,jp) / grad_mag_north;
                    coupling_flux_y_south = coupling_coeff_south * phi_change_rate * phidy(i,jm) / grad_mag_south;

                    % Calculate divergence | 计算散度
                    div_coupling = (coupling_flux_x_east - coupling_flux_x_west)/(2*dx) + ...
                                   (coupling_flux_y_north - coupling_flux_y_south)/(2*dy);
                end

                % Term 3: Source term (1+(1-k)U)/2 ∂ϕ/∂t
                % 项3: 源项 (1+(1-k)U)/2 ∂ϕ/∂t
                source_term = (1.0 + (1.0 - k_partition) * U_old_val) / 2.0 * phi_change_rate;

                % Term 4: Advection flux term -(1-ϕ)(1-k)/4 v · { [1+k - (1-k)ϕ] ∇U - [1+(1-k)U] ∇ϕ }
                % 项4: 对流通量项 -(1-ϕ)(1-k)/4 v · { [1+k - (1-k)ϕ] ∇U - [1+(1-k)U] ∇ϕ }

                if ~strcmp(velocity_field_type, 'none')
                    % Calculate velocity field at this point | 计算该点的速度场
                    [v_x_raw, v_y_raw] = calculate_velocity_field(i, j, Nx, Ny, dx, dy, ...
                        velocity_field_type, v_x_magnitude, v_y_magnitude, shear_rate, vortex_strength);

                    % === Permeability Model: Solid Phase No-Slip Approximation ===
                    % === 渗透率模型：固相无滑移近似 ===
                    % Map phi from [-1, 1] to [0, 1] (0: liquid, 1: solid)
                    % 将 phi 从 [-1, 1] 映射到 [0, 1]（0：液相，1：固相）
                    solid_fraction = (phi(i,j) + 1.0) / 2.0;
                    solid_fraction = max(0.0, min(1.0, solid_fraction));  % Clamp to [0, 1] | 截断到 [0, 1]

                    % Simple permeability model: velocity is zero in solid phase
                    % 简单的渗透率模型：固相内速度为0
                    % Using (1-phi)^2 as a smooth function to gradually reduce velocity
                    % 使用 (1-phi)^2 作为平滑函数来逐渐减小速度
                    permeability_factor = (1.0 - solid_fraction)^2;

                    v_x_local = v_x_raw * permeability_factor;
                    v_y_local = v_y_raw * permeability_factor;
                    % === End of Permeability Model ===
                    % === 渗透率模型结束 ===

                    % Calculate advection coefficient | 计算对流项系数
                    advection_coeff = -(1.0 - phi_old_val) * (1.0 - k_partition) / 4.0;

                    % Calculate vector inside braces | 计算括号内的向量
                    coeff_U = (1.0 + k_partition - (1.0 - k_partition) * phi_old_val);
                    coeff_phi = (1.0 + (1.0 - k_partition) * U_old_val);

                    vector_x = coeff_U * Udx(i,j) - coeff_phi * phidx(i,j);
                    vector_y = coeff_U * Udy(i,j) - coeff_phi * phidy(i,j);

                    % Dot product v · vector | 点积 v · vector
                    dot_product = v_x_local * vector_x + v_y_local * vector_y;

                    advection_term = advection_coeff * dot_product;
                else
                    advection_term = 0;  % No velocity field | 无速度场
                end

                % Concentration field right-hand side term | 浓度场右端项
                U_rhs = div_diffusion + div_coupling + source_term + advection_term;

                % Time scale coefficient | 时间尺度系数
                S_coefficient = ((1.0 + k_partition) - (1.0 - k_partition) * phi_old_val) / 2.0;

                % Concentration field time integration | 浓度场时间积分
                U_new = U_old_val + dtime * U_rhs / S_coefficient;
                U(i,j) = U_new;
            end
        end

        % Update simulation time | 更新模拟时间
        current_time = current_time + dtime;

        % Handle final incomplete time step | 处理最后的非完整时间步
        if current_time + dtime > total_time
            final_dtime = total_time - current_time;
            if final_dtime > 1e-12  % If there's still time to process | 如果还有时间需要处理
                % Use adjusted time step for final step
                % 注意：这里简化处理，为了精确到达total_time
                current_time = total_time;
            end
        end

        % Output results (based on time interval) | 输出结果（基于时间间隔）
        if (current_time >= next_print_time || current_time >= total_time) && istep >= 20
            fprintf('时间: %.4f/%.1fs (%.1f%%), 步数: %d, 界面点数: %d (%.2f%%)\n', ...
                    current_time, total_time, 100*current_time/total_time, istep, interface_points, interface_percentage);

            % === Interface tracking | === 界面追踪
            % Interface tracking contour extraction | 界面追踪等值线提取
            contour_level = 0;

            % Create coordinate grid | 创建坐标网格
            x_coords = ((0:Nx-1) + 0.5) * dx;
            y_coords = ((0:Ny-1) + 0.5) * dy;

            % Extract specified contour line | 提取指定等值线
            [C, h] = contour(x_coords, y_coords, phi, [contour_level contour_level]);

            % If contour data exists | 如果有等值线数据
            if ~isempty(C)
                % Extract coordinates from contour matrix C | 从轮廓矩阵C中提取坐标
                contour_data = [];
                i = 1;
                while i < size(C, 2)
                    level = C(1, i);
                    num_points = C(2, i);

                    if num_points > 0
                        x_coords_contour = C(1, i+1:i+num_points);
                        y_coords_contour = C(2, i+1:i+num_points);

                        if isempty(contour_data)
                            contour_data = [x_coords_contour(:), y_coords_contour(:)];
                        else
                            contour_data = [contour_data; x_coords_contour(:), y_coords_contour(:)];
                        end
                    end

                    i = i + num_points + 1;
                end

                % Filter valid contour points (avoid boundary anomalies) | 筛选有效的等值线点 (避免边界异常)
                valid_points = true(size(contour_data, 1), 1);

                for i = 2:size(contour_data, 1)-1
                    % Calculate distance between adjacent points | 计算相邻点的距离
                    dist_x = contour_data(i, 1) - contour_data(i-1, 1);
                    dist_y = contour_data(i, 2) - contour_data(i-1, 2);
                    dist = sqrt(dist_x^2 + dist_y^2);

                    % If distance exceeds reasonable range, mark as invalid | 如果距离超过合理范围，标记为无效
                    max_reasonable_dist = 3 * max(dx, dy);
                    if dist > max_reasonable_dist
                        % Check if near boundary | 检查是否接近边界
                        if contour_data(i, 1) < 2*dx || contour_data(i, 1) > (Nx-2)*dx || ...
                           contour_data(i, 2) < 2*dy || contour_data(i, 2) > (Ny-2)*dy
                            valid_points(i) = false;
                        end
                    end
                end

                % Extract valid points | 提取有效点
                if sum(valid_points) > 2
                    contour_data = contour_data(valid_points, :);
                end
            else
                contour_data = [];
            end

            contour_lines = C;
            interface_length = size(contour_data, 1);
            fprintf('界面长度: %.2f 网格单位\n', interface_length);

            % Save history data | 保存历史数据
            save_count = save_count + 1;
            if save_count <= max_saves
                phi_history{save_count} = phi;
                U_history{save_count} = U;
                time_history(save_count) = current_time;
                interface_history(save_count) = interface_length;
                contour_history{save_count} = contour_data;

                % === Save velocity field with permeability model | === 保存带渗透率模型的速度场
                if ~strcmp(velocity_field_type, 'none')
                    Vx_frame = zeros(Ny, Nx);
                    Vy_frame = zeros(Ny, Nx);

                    for i = 1:Nx
                        for j = 1:Ny
                            % Calculate raw velocity field
                            % 计算原始速度场
                            [v_x_raw, v_y_raw] = calculate_velocity_field(i, j, Nx, Ny, dx, dy, ...
                                velocity_field_type, v_x_magnitude, v_y_magnitude, shear_rate, vortex_strength);

                            % Apply permeability model (same as in visualization)
                            % 应用渗透率模型（与可视化相同）
                            phi_val = phi(j, i);
                            solid_fraction = (phi_val + 1.0) / 2.0;
                            solid_fraction = max(0.0, min(1.0, solid_fraction));
                            permeability_factor = (1.0 - solid_fraction)^2;

                            v_x_local = v_x_raw * permeability_factor;
                            v_y_local = v_y_raw * permeability_factor;

                            % Swap x and y components to fix axis orientation
                            % 交换x和y分量以修正轴向
                            Vx_frame(j,i) = v_y_local;
                            Vy_frame(j,i) = v_x_local;
                        end
                    end

                    Vx_history{save_count} = Vx_frame;
                    Vy_history{save_count} = Vy_frame;
                else
                    % No velocity field, save empty arrays
                    % 无速度场，保存空数组
                    Vx_history{save_count} = zeros(Ny, Nx);
                    Vy_history{save_count} = zeros(Ny, Nx);
                end
                % === End of velocity field saving ===

                % Update next output time | 更新下次输出时间
                next_print_time = next_print_time + print_interval;

                % === Six-fold symmetric dendrite tip tracking analysis | === 六重对称枝晶尖端追踪分析
                if enable_tip_tracking
                    fprintf('开始六尖端追踪分析...\n');

                    % Boundary particle resampling processing | 边界粒子重采样处理
                    if enable_resampling && ~isempty(contour_data) && size(contour_data, 1) > 3
                        target_spacing = 0.4;
                        contour_data = resample_contour_equidistant(contour_data, target_spacing);
                    end

                    % Use six-tip detection algorithm | 使用六尖端检测算法
                    six_tips_info = find_six_tips_direction_specific(...
                        contour_data, cx, cy, dx, dy, tip_history_buffer_6, six_tip_angles);

                    % Calculate six-tip dynamics parameters | 计算六尖端动力学参数
                    [six_tips_dynamics, tip_history_buffer_6] = calculate_six_tip_dynamics(...
                        six_tips_info, contour_data, tip_history_buffer_6, istep, dtime, cx, cy, dx, dy);

                    % Store six-tip data | 存储六尖端数据
                    for tip_id = 1:6
                        if six_tips_dynamics(tip_id).is_valid
                            tip_position_history_6(save_count, tip_id, :) = six_tips_dynamics(tip_id).position;
                            tip_distance_history_6(save_count, tip_id) = six_tips_dynamics(tip_id).distance;
                            tip_velocity_history_6(save_count, tip_id) = six_tips_dynamics(tip_id).velocity;
                            tip_curvature_history_6(save_count, tip_id) = six_tips_dynamics(tip_id).curvature_radius;
                        else
                            tip_position_history_6(save_count, tip_id, :) = [0, 0];
                            tip_distance_history_6(save_count, tip_id) = 0;
                            tip_velocity_history_6(save_count, tip_id) = 0;
                            tip_curvature_history_6(save_count, tip_id) = 0;
                        end
                    end
                end
            end

            % Visualization update | 可视化更新
            if visualization_mode
                % Update figure(2): phase field, concentration field, C/C∞
                % 更新figure(2)：相场、浓度场、C/C∞
                update_corrected_visualization(phi, U, istep, [], Nx, Ny, 0.5, k_partition);

                % Update figure(3): interface tracking analysis
                % 更新figure(3)：界面追踪分析
                update_interface_visualization(phi, contour_data, interface_length, istep, ...
                    time_history, interface_history(1:save_count), Nx, Ny, dx, dy, [], [], [], []);

                % Update figure(4): velocity field visualization (if enabled)
                % 更新figure(4)：速度场可视化（如果启用）
                if ~strcmp(velocity_field_type, 'none')
                    update_velocity_visualization(phi, istep, Nx, Ny, dx, dy, ...
                        velocity_field_type, v_x_magnitude, v_y_magnitude, shear_rate, vortex_strength, velocity_video_writer);
                end

                drawnow;
            end
        end
    end

    % Close velocity field video writer (if opened)
    % 关闭速度场视频写入对象（如果已打开）
    if ~isempty(velocity_video_writer) && ishandle(velocity_video_writer)
        close(velocity_video_writer);
        fprintf('✓ 速度场视频录制已完成并保存\n');
    end

    %% ==================== Section 9: Array Cleanup ====================
    % 数组清理（裁剪到实际使用大小）
    fprintf('\n清理数组到实际使用大小...\n');
    if save_count < max_saves
        phi_history = phi_history(1:save_count);
        U_history = U_history(1:save_count);
        time_history = time_history(1:save_count);
        Vx_history = Vx_history(1:save_count);
        Vy_history = Vy_history(1:save_count);
        interface_history = interface_history(1:save_count);
        contour_history = contour_history(1:save_count);
        tip_position_history_6 = tip_position_history_6(1:save_count, :, :);
        tip_distance_history_6 = tip_distance_history_6(1:save_count, :);
        tip_velocity_history_6 = tip_velocity_history_6(1:save_count, :);
        tip_curvature_history_6 = tip_curvature_history_6(1:save_count, :);
        fprintf('数组已裁剪: %d -> %d 个保存点\n', max_saves, save_count);
    else
        fprintf('数组大小无需调整: %d 个保存点\n', save_count);
    end

    fprintf('模拟完成! 实际运行时间: %.4f/%.1f τ₀\n', current_time, total_time);

    %% ==================== Section 10: Post-Processing ====================
    % 后处理

    % Video generation | 视频生成
    if isfield(params, 'save_video') && params.save_video && visualization_mode
        fprintf('\n正在生成视频...\n');
        generate_simulation_videos(phi_history, U_history, time_history, ...
            contour_history, Vx_history, Vy_history, velocity_field_type, Nx, Ny, dx, dy, ...
            k_partition, params, velocity_field_type, v_x_magnitude, ...
            v_y_magnitude, shear_rate, vortex_strength);
        fprintf('视频生成完成!\n');
    end

    % Six-fold symmetric dendrite tip analysis and visualization | 六重对称枝晶尖端分析和可视化
    if enable_tip_tracking
        fprintf('\n进行六尖端动力学分析...\n');
        plot_six_tip_dynamics_analysis(time_history, tip_position_history_6, ...
            tip_distance_history_6, tip_velocity_history_6, tip_curvature_history_6, print_interval);

        % Individual tip detailed analysis | 各个尖端专项分析
        valid_time_steps = time_history > 0;
        valid_times = time_history(valid_time_steps);

        for tip_id = 1:6
            fprintf('\n进行尖端%d专项分析...\n', tip_id);
            if length(valid_times) >= 2
                tip_velocities = tip_velocity_history_6(valid_time_steps, tip_id);
                tip_curvatures = tip_curvature_history_6(valid_time_steps, tip_id);

                % Data validation | 数据验证
                valid_velocity_mask = abs(tip_velocities) > 1e-6;
                valid_curvature_mask = isfinite(tip_curvatures) & tip_curvatures > 0 & tip_curvatures < 100;

                if sum(valid_velocity_mask) > 0 || sum(valid_curvature_mask) > 0
                    generate_tip_detailed_analysis(valid_times, tip_velocities, tip_curvatures, tip_id);
                else
                    fprintf('尖端%d数据不足，跳过专项分析\n', tip_id);
                end
            else
                fprintf('尖端%d数据不足，跳过专项分析\n', tip_id);
            end
        end
    end

    %% ==================== Section 11: Save Results ====================
    % 保存结果
    output_filename = params.output_filename;
    save(output_filename, ...
         'phi_history', 'U_history', 'time_history', ...
         'interface_history', 'contour_history', ...
         'tip_position_history_6', 'tip_distance_history_6', ...
         'tip_velocity_history_6', 'tip_curvature_history_6', ...
         'six_tip_angles', 'six_tip_directions', 'six_reference_lines', ...
         'phi', 'U', 'Nx', 'Ny', 'dx', 'dy', ...
         'total_time', 'dtime', 'current_time', ...
         'k_partition', 'epsilon_aniso', 'm_aniso', ...
         'lambda_coup', 'D_coefficient', 'theta_field');

    fprintf('结果已保存到: %s\n', output_filename);

    %% ==================== Section 12: Prepare Output Structure ====================
    % 准备输出结构体
    results = struct();
    results.phi_history = phi_history;
    results.U_history = U_history;
    results.time_history = time_history;
    results.tip_position_history_6 = tip_position_history_6;
    results.tip_distance_history_6 = tip_distance_history_6;
    results.tip_velocity_history_6 = tip_velocity_history_6;
    results.tip_curvature_history_6 = tip_curvature_history_6;
    results.interface_history = interface_history;
    results.final_phi = phi;
    results.final_U = U;
    results.params = params;
    results.total_steps = istep;
    results.final_time = current_time;

    compute_time = etime(clock(), time0);
    fprintf('\n总计算时间 (wall-clock time): %.2f 秒\n', compute_time);

    %% ==================== Local Helper Functions ====================
    % 局部辅助函数

    function [ip, im, jp, jm] = apply_boundary_conditions(i, j, Nx, Ny, bc_type)
        % Apply boundary conditions: periodic or zero-gradient
        % 应用边界条件：周期性或零梯度
        %
        % Supports two boundary condition types for greater flexibility
        % 支持两种边界条件类型以提供更大的灵活性

        jp = j + 1;    % North neighbor point | 上方邻居点
        jm = j - 1;    % South neighbor point | 下方邻居点
        ip = i + 1;    % Right neighbor point | 右方邻居点
        im = i - 1;    % Left neighbor point | 左方邻居点

        switch lower(bc_type)
            case 'periodic'
                % Periodic boundary conditions (original logic)
                % 周期性边界条件（原有逻辑）
                % Left-right boundary periodic connection | 左右边界周期连接
                if im == 0,        im = Nx;    end
                if ip == (Nx+1),   ip = 1;     end
                % Top-bottom boundary periodic connection | 上下边界周期连接
                if jm == 0,        jm = Ny;    end
                if jp == (Ny+1),   jp = 1;     end

            case 'zero_gradient'
                % Zero-gradient boundary conditions (new logic)
                % 零梯度边界条件（新增逻辑）
                % At boundary use nearest interior point value, achieving zero gradient condition
                % 边界处使用最近的内点值，实现梯度为零的条件
                % Left-right boundary zero gradient | 左右边界零梯度
                if im == 0,        im = 1;     end
                if ip == (Nx+1),   ip = Nx;    end
                % Top-bottom boundary zero gradient | 上下边界零梯度
                if jm == 0,        jm = 1;     end
                if jp == (Ny+1),   jp = Ny;    end

            otherwise
                error('未知的边界条件类型: %s。请使用 ''periodic'' 或 ''zero_gradient''', bc_type);
        end
    end

    function initialize_corrected_visualization(Nx, Ny)
        % Initialize visualization figure window
        % 初始化可视化图形窗口
        %
        % Inputs:
        %   Nx, Ny - Grid dimensions | 网格尺寸

        figure(2);
        set(gcf, 'Name', 'Phase Field & Concentration Field', 'Position', [100, 100, 1800, 500]);

        % Phase field display | 相场显示
        subplot(1, 3, 1);
        imagesc(zeros(Ny, Nx));
        colormap(jet);
        colorbar;
        title('相场分布 ϕ');
        xlabel('x'); ylabel('y');
        axis equal tight;
        caxis([-1, 1]);

        % Concentration field display | 浓度场显示
        subplot(1, 3, 2);
        imagesc(zeros(Ny, Nx));
        colormap(jet);
        colorbar;
        title('浓度场分布 U');
        xlabel('x'); ylabel('y');
        axis equal tight;
        caxis([0, 2.5]);

        % C/C∞ cloud display | C/C∞云图显示
        subplot(1, 3, 3);
        imagesc(zeros(Ny, Nx));
        colormap(jet);
        colorbar;
        title('浓度比分布 C/C∞');
        xlabel('x'); ylabel('y');
        axis equal tight;
        caxis([0, 2.5]);

        drawnow;
    end

    function update_corrected_visualization(phi, U, istep, probe_data, Nx, Ny, y_ratio, k_partition)
        % Update visualization, integrating probe line analysis functionality
        % 更新可视化，集成探测线分析功能
        %
        % Inputs:
        %   phi, U - Phase and concentration fields | 相场和浓度场
        %   istep - Current time step | 当前时间步
        %   probe_data - Probe line data (optional) | 探测线数据（可选）
        %   Nx, Ny - Grid dimensions | 网格尺寸
        %   y_ratio - Probe line position ratio | 探测线位置比例
        %   k_partition - Partition coefficient | 分配系数

        figure(2);

        % Update phase field display | 更新相场显示
        subplot(1, 3, 1);
        imagesc(phi');
        title(sprintf('相场分布 ϕ - 步数 %d', istep));
        caxis([-1, 1]);
        xlabel('x'); ylabel('y');
        axis equal tight;
        colorbar;

        % Update concentration field display | 更新浓度场显示
        subplot(1, 3, 2);
        imagesc(U');
        title(sprintf('浓度场分布 U - 步数 %d', istep));
        caxis([0, 2.5]);
        xlabel('x'); ylabel('y');
        axis equal tight;
        colorbar;

        % Calculate and update C/C∞ cloud display | 计算并更新C/C∞云图显示
        subplot(1, 3, 3);
        CCinf_field = calculate_CCinf_from_fields(phi, U, k_partition);
        imagesc(CCinf_field');
        title(sprintf('浓度比分布 C/C∞ - 步数 %d', istep));
        caxis([0, 2.5]);
        xlabel('x'); ylabel('y');
        axis equal tight;
        colorbar;

        drawnow;
    end

    function CCinf_ratio = calculate_CCinf_from_fields(phi, U, k_partition)
        % Calculate C/C∞ ratio
        % 计算C/C∞比值
        %
        % Based on formula: U = ((2C/C∞)/(1+k-(1-k)φ) - 1)/(1-k)
        % Solve to get: C/C∞ = (U*(1-k) + 1) * (1+k-(1-k)φ) / 2
        % 基于公式: U = ((2C/C∞)/(1+k-(1-k)φ) - 1)/(1-k)
        % 反解得到: C/C∞ = (U*(1-k) + 1) * (1+k-(1-k)φ) / 2

        CCinf_ratio = (U .* (1 - k_partition) + 1) .* ...
                      (1 + k_partition - (1 - k_partition) .* phi) / 2;

        % Add numerical stability handling | 添加数值稳定性处理
        CCinf_ratio(isnan(CCinf_ratio)) = 0;
        CCinf_ratio(isinf(CCinf_ratio)) = 0;
    end

    function initialize_interface_visualization(Nx, Ny, dx, dy)
        % Initialize solid-liquid interface tracking visualization window (figure(3))
        % Create 2x2 subplot layout for interface tracking analysis
        % 初始化固液界面追踪可视化窗口 (figure(3))
        % 创建2x2子图布局用于界面追踪分析
        %
        % Inputs:
        %   Nx, Ny - Grid dimensions | 网格尺寸
        %   dx, dy - Spatial step sizes | 空间步长

        figure(3);
        set(gcf, 'Name', 'Solid-Liquid Interface Tracking Analysis', 'Position', [200, 200, 1200, 900]);

        % Subplot 1: Interface contour real-time display (top-left)
        subplot(2, 2, 1);
        imagesc(zeros(Ny, Nx));
        colormap('gray');
        title('Interface Contour Real-time Display', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('y (W)');
        ylabel('x (W)');
        axis equal tight;
        hold on;

        subplot(2, 2, 2);
        plot([], 'b-', 'LineWidth', 2, 'Marker', 'o');
        title('Interface Length Evolution', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('Time Step');
        ylabel('Interface Length (W)');
        grid on;

        subplot(2, 2, 3);
        scatter([], [], 20, 'filled');
        title('Interface Coordinate Distribution', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('x Coordinate (W)');
        ylabel('y Coordinate (W)');
        grid on;
        axis equal;

        subplot(2, 2, 4);
        axis off;

        sgtitle('Solid-Liquid Interface Tracking Dynamic Analysis System', 'FontSize', 14, 'FontWeight', 'bold');

        drawnow;
    end

    function update_interface_visualization(phi, contour_data, interface_length, istep, time_history, interface_history, Nx, Ny, dx, dy, tip_pos, tip_distance, tip_velocity, tip_curvature_radius)
        % Update solid-liquid interface tracking visualization window
        % 更新固液界面追踪可视化窗口
        %
        % Input parameters:
        %   phi - Current phase field distribution | 当前相场分布
        %   contour_data - Current interface coordinate data [x_coords, y_coords] | 当前界面坐标数据
        %   interface_length - Current interface length | 当前界面长度
        %   istep - Current time step | 当前时间步
        %   time_history - Time history array | 时间历史数组
        %   interface_history - Interface length history array | 界面长度历史数组
        %   Nx, Ny - Grid dimensions | 网格尺寸
        %   dx, dy - Spatial step sizes | 空间步长
        %   tip_pos - Current tip position [x, y] | 当前尖端位置
        %   tip_distance - Distance from tip to center | 尖端到中心的距离
        %   tip_velocity - Tip growth velocity | 尖端生长速度
        %   tip_curvature_radius - Tip curvature radius | 尖端曲率半径

        figure(3);

        % Subplot 1: Interface contour real-time display
        subplot(2, 2, 1);
        imagesc(phi');
        colormap('gray');
        title(sprintf('Interface Contour - Step %d', istep), 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('y'); ylabel('x');
        axis equal tight;

        % Subplot 2: Interface length evolution
        subplot(2, 2, 2);
        plot(interface_history, 'b-', 'LineWidth', 2);
        title('Interface Length Evolution', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('Save Index');
        ylabel('Interface Length');
        grid on;

        % Subplot 3: Interface coordinate distribution
        subplot(2, 2, 3);
        if ~isempty(contour_data)
            scatter(contour_data(:, 2), contour_data(:, 1), 15, 'filled');
        end
        title('Interface Coordinate Distribution', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('y'); ylabel('x');
        grid on;
        axis equal;

        drawnow;
    end

    function [v_x, v_y] = calculate_velocity_field(i, j, Nx, Ny, dx, dy, velocity_type, v_x_mag, v_y_mag, shear, vortex)
        % Calculate velocity field at specified grid point
        % 计算指定网格点的速度场
        %
        % Inputs:
        %   i, j - Grid position indices | 网格位置索引
        %   Nx, Ny - Grid dimensions | 网格尺寸
        %   dx, dy - Spatial step sizes | 空间步长
        %   velocity_type - Type of velocity field ('none', 'uniform', 'shear', 'vortex')
        %                  速度场类型 ('none', 'uniform', 'shear', 'vortex')
        %   v_x_mag, v_y_mag - Velocity magnitudes for uniform flow | 均匀流速度幅度
        %   shear - Shear rate for shear flow | 剪切流的剪切速率
        %   vortex - Vortex strength for vortex flow | 涡旋流的涡旋强度
        %
        % Outputs:
        %   v_x, v_y - Velocity components at point (i, j) | 点(i, j)处的速度分量

        % Convert to physical coordinates | 转换为物理坐标
        x_pos = i * dx;
        y_pos = j * dy;

        % Calculate computational domain center coordinates | 计算域中心坐标
        x_center = Nx * dx / 2.0;
        y_center = Ny * dy / 2.0;

        switch lower(velocity_type)
            case 'none'
                % No velocity field | 无速度场
                v_x = 0.0;
                v_y = 0.0;

            case 'uniform'
                % Uniform velocity field | 均匀速度场
                v_x = v_x_mag;
                v_y = v_y_mag;

            case 'shear'
                % Shear flow: v_x = shear * (y - y_center), v_y = 0
                % 剪切流：v_x = shear * (y - y_center), v_y = 0
                v_x = shear * (y_pos - y_center);
                v_y = 0.0;

            case 'vortex'
                % Vortex flow: rotational flow around center
                % 涡旋流：绕中心的旋转流场
                dx_center = x_pos - x_center;
                dy_center = y_pos - y_center;
                r = sqrt(dx_center^2 + dy_center^2);

                if r > eps
                    % Tangential velocity, counter-clockwise rotation | 切向速度，逆时针旋转
                    v_x = -vortex * dy_center / r;
                    v_y = vortex * dx_center / r;
                else
                    v_x = 0.0;
                    v_y = 0.0;
                end

            otherwise
                % Unknown velocity field type, default to no flow
                % 未知的速度场类型，默认为无流动
                v_x = 0.0;
                v_y = 0.0;
        end
    end

    function initialize_velocity_visualization(Nx, Ny, dx, dy)
        % Initialize velocity field visualization window
        % 初始化速度场可视化窗口
        %
        % Inputs:
        %   Nx, Ny - Grid dimensions | 网格尺寸
        %   dx, dy - Spatial step sizes | 空间步长

        figure(4);
        set(gcf, 'Name', 'Velocity Field Visualization', 'Position', [300, 100, 800, 600]);

        % Create meshgrid for quiver plot
        [X, Y] = meshgrid((1:Nx)*dx, (1:Ny)*dy);

        % Initial quiver plot (zero velocity)
        quiver(X, Y, zeros(Ny, Nx), zeros(Ny, Nx), 0, 'AutoScale', 'on');
        title('Velocity Field (Initialized)', 'FontSize', 14, 'FontWeight', 'bold');
        xlabel('x (W)');
        ylabel('y (W)');
        axis equal tight;
        grid on;

        drawnow;
    end

    function update_velocity_visualization(phi, istep, Nx, Ny, dx, dy, velocity_type, v_x_mag, v_y_mag, shear, vortex, video_writer)
        % Update velocity field visualization
        % 更新速度场可视化
        %
        % Inputs:
        %   phi - Phase field (for masking liquid region) | 相场（用于液相区域遮罩）
        %   istep - Current time step | 当前时间步
        %   Nx, Ny - Grid dimensions | 网格尺寸
        %   dx, dy - Spatial step sizes | 空间步长
        %   velocity_type - Type of velocity field | 速度场类型
        %   v_x_mag, v_y_mag - Uniform flow parameters | 均匀流参数
        %   shear - Shear rate for shear flow | 剪切流的剪切速率
        %   vortex - Vortex strength for vortex flow | 涡旋流的涡旋强度
        %   video_writer - Optional VideoWriter object for recording | 可选的视频写入对象

        figure(4);

        % Create meshgrid for quiver plot
        [X, Y] = meshgrid((1:Nx)*dx, (1:Ny)*dy);

        % Calculate velocity field at all grid points
        Vx = zeros(Ny, Nx);
        Vy = zeros(Ny, Nx);

        for i = 1:Nx
            for j = 1:Ny
                % Calculate raw velocity field
                % 计算原始速度场
                [v_x_raw, v_y_raw] = calculate_velocity_field(i, j, Nx, Ny, dx, dy, ...
                    velocity_type, v_x_mag, v_y_mag, shear, vortex);

                % === Apply Permeability Model for Visualization ===
                % === 应用渗透率模型用于可视化 ===
                % Map phi from [-1, 1] to [0, 1] (0: liquid, 1: solid)
                % 将phi从[-1, 1]映射到[0, 1]（0：液相，1：固相）
                phi_val = phi(j, i);
                solid_fraction = (phi_val + 1.0) / 2.0;
                solid_fraction = max(0.0, min(1.0, solid_fraction));  % Clamp to [0, 1]

                % Simple permeability model: velocity is zero in solid phase
                % 简单渗透率模型：固相内速度为零
                permeability_factor = (1.0 - solid_fraction)^2;

                % Apply permeability model
                % 应用渗透率模型
                v_x_local = v_x_raw * permeability_factor;
                v_y_local = v_y_raw * permeability_factor;

                % Swap x and y components to fix axis orientation
                % 交换x和y分量以修正轴向
                Vx(j,i) = v_y_local;   % Store v_y_local in Vx (swap)
                Vy(j,i) = v_x_local;   % Store v_x_local in Vy (swap)
                % === End of Permeability Model ===
            end
        end

        % Mask: only show velocity in liquid region (phi < 0)
        % 创建遮罩：只在液相区域显示速度（phi < 0）
        liquid_mask = phi < 0;

        % Downsample for clearer visualization (show every 8th arrow)
        % 降采样以便更清晰的可视化（每8个箭头显示1个）
        skip = 8;
        X_ds = X(1:skip:end, 1:skip:end);
        Y_ds = Y(1:skip:end, 1:skip:end);
        Vx_ds = Vx(1:skip:end, 1:skip:end);
        Vy_ds = Vy(1:skip:end, 1:skip:end);
        mask_ds = liquid_mask(1:skip:end, 1:skip:end);

        % Clear and redraw
        clf;
        hold on;

        % Plot velocity vectors only in liquid region
        % 只在液相区域绘制速度矢量
        if any(mask_ds(:))
            quiver(X_ds(mask_ds), Y_ds(mask_ds), Vx_ds(mask_ds), Vy_ds(mask_ds), ...
                0, 'AutoScale', 'on', 'Color', 'r', 'LineWidth', 1.5);
        end

        % Overlay phase field contour as background
        % 叠加相场等高线作为背景
        contour(X, Y, phi, [0 0], 'k-', 'LineWidth', 0.5);
        title(sprintf('Velocity Field - Step %d (%s)', istep, velocity_type), ...
            'FontSize', 14, 'FontWeight', 'bold');
        xlabel('x (W)');
        ylabel('y (W)');
        axis equal tight;
        grid on;
        colorbar;
        caxis([-1, 1]);
        colormap('gray');

        hold off;
        drawnow;

        % === Record frame to video if video_writer is provided ===
        % === 如果提供了video_writer，录制帧到视频 ===
        if nargin >= 11 && ~isempty(video_writer)
            frame = getframe(gcf);
            writeVideo(video_writer, frame);
        end
    end

    function generate_simulation_videos(phi_history, U_history, time_history, ...
            contour_history, Vx_history, Vy_history, velocity_field_type, Nx, Ny, dx, dy, ...
            k_partition, params, vftype, vx_mag, vy_mag, shear, vortex)
        % Generate simulation videos from saved history data
        % 从保存的历史数据生成模拟视频
        %
        % Inputs:
        %   phi_history - Phase field history | 相场历史
        %   U_history - Concentration field history | 浓度场历史
        %   time_history - Time array | 时间数组
        %   Vx_history - Velocity field X component history (with permeability model) | 速度场X分量历史（带渗透率模型）
        %   Vy_history - Velocity field Y component history (with permeability model) | 速度场Y分量历史（带渗透率模型）
        %   ... (other parameters)

        fprintf('开始视频生成...\n');

        % Determine video filename prefix based on velocity field
        % 根据速度场确定视频文件名前缀
        if isfield(params, 'velocity_field') && ~strcmp(params.velocity_field, 'none')
            video_prefix = 'velocity_field_';
        else
            video_prefix = 'basic_growth_';
        end

        % Get FPS from params or use default
        fps = 10;
        if isfield(params, 'video_fps')
            fps = params.video_fps;
        end

        n_frames = length(phi_history);
        fprintf('总帧数: %d\n', n_frames);

        %% Video 1: Combined fields video (phase + concentration + C/C∞)
        %% 视频1：合并场视频（相场 + 浓度场 + C/C∞）
        fprintf('生成合并场演化视频（3个子图）...\n');
        video_combined = VideoWriter(sprintf('%scombined.mp4', video_prefix), 'MPEG-4');
        video_combined.FrameRate = fps;
        open(video_combined);

        for i = 1:n_frames
            % Extract frame data
            if iscell(phi_history)
                phi_frame = phi_history{i};
                U_frame = U_history{i};
            else
                phi_frame = phi_history(:, :, i);
                U_frame = U_history(:, :, i);
            end

            % Calculate C/C∞
            CCinf_ratio = ((1 + k_partition - (1 - k_partition) .* phi_frame) / 2) ...
                         .* (1 + U_frame);
            CCinf_ratio(isnan(CCinf_ratio)) = 0;
            CCinf_ratio(isinf(CCinf_ratio)) = 0;

            % Create figure with 3 subplots
            figure(100);
            set(gcf, 'Position', [100, 100, 1800, 600]);

            % Subplot 1: Phase field
            subplot(1, 3, 1);
            imagesc(phi_frame');
            caxis([-1, 1]);
            colormap(jet);
            colorbar;
            title(sprintf('Phase Field\\nTime: %.2f \\tau_0', time_history(i)), ...
                'FontSize', 12, 'FontWeight', 'bold');
            xlabel('x'); ylabel('y');
            axis equal tight;

            % Subplot 2: Concentration field
            subplot(1, 3, 2);
            imagesc(U_frame');
            colorbar;
            title(sprintf('Concentration (U)\\nTime: %.2f \\tau_0', time_history(i)), ...
                'FontSize', 12, 'FontWeight', 'bold');
            xlabel('x'); ylabel('y');
            axis equal tight;

            % Subplot 3: C/C∞ field
            subplot(1, 3, 3);
            imagesc(CCinf_ratio');
            caxis([0, 2.5]);
            colorbar;
            title(sprintf('C/C_\\infty\\nTime: %.2f \\tau_0', time_history(i)), ...
                'FontSize', 12, 'FontWeight', 'bold');
            xlabel('x'); ylabel('y');
            axis equal tight;

            frame = getframe(gcf);
            writeVideo(video_combined, frame);

            if mod(i, 10) == 0
                fprintf('  进度: %d/%d\n', i, n_frames);
            end
        end
        close(video_combined);
        fprintf('✓ 合并场视频已保存: %scombined.mp4\n', video_prefix);

        % Close temporary figure
        close(100);

        fprintf('所有视频生成完成!\n');
    end

end
